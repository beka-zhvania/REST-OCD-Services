package i5.las2peer.services.ocd.automatedtesting.ocdparser;

import i5.las2peer.services.ocd.algorithms.OcdAlgorithm;
import i5.las2peer.services.ocd.automatedtesting.ocdparser.helpers.OCDATestExceptionHandler;
import i5.las2peer.services.ocd.graphs.Cover;
import i5.las2peer.services.ocd.graphs.CustomGraph;
import i5.las2peer.services.ocd.test_interfaces.ocda.*;
import i5.las2peer.services.ocd.testsUtils.OcdTestGraphFactory;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;

import static i5.las2peer.services.ocd.automatedtesting.ocdparser.OCDAParser.*;

public class PromptGenerator {



    /*  Constants related to graph types */
    // Method names to fetch graphs to be used in auto-generated tests
    //TODO: add/replace method names
    public static String UNDIRECTED_GRAPH_METHOD_NAME = "getSawmillGraph";
    public static String DIRECTED_GRAPH_METHOD_NAME = "getDirectedAperiodicTwoCommunitiesGraph";
    public static String WEIGHTED_GRAPH_METHOD_NAME = "getTwoCommunitiesWeightedGraph";

    public static String ZERO_WEIGHTS_GRAPH_METHOD_NAME = "todoZeroWeights"; //TODO: replace string with appropriate method name

    public static String NEGATIVE_WEIGHTS_GRAPH_METHOD_NAME = "todoNegativeWeights"; //TODO: replace string with appropriate method name

    public static String SELF_LOOPS_GRAPH_METHOD_NAME = "todoSelfLoops"; //TODO: replace string with appropriate method name

    // Name of the class where the test graphs are stored or generated
    public static String GRAPH_FACTORY_CLASS_NAME = "OcdTestGraphFactory";

    // Name of the shared method among OCDA test classes to get an algorithm instance
    public static String OCDA_GETTER = "getAlgorithm";

    // Name of the graph class used in WebOCD
    public static String GRAPH_CLASS_NAME = "CustomGraph";

    // Name of the method to set algorithm parameters
    public static String SET_OCD_PARAMETERS_METHOD_NAME = "setParameters";

    public static String TEST_CLASS_PACKAGE_STRING = "i5.las2peer.services.ocd.algorithms";

    /*  Constants related to test names that must be auto-completed by ChatGPT */

    public static String UNDIRECTED_GRAPH_TEST_NAME = "undirectedGraphTest1";

    public static String DIRECTED_GRAPH_TEST_NAME = "directedGraphTest1";

    public static String WEIGHTED_GRAPH_TEST_NAME = "weightedGraphTest1";

    public static String ZERO_WEIGHTS_GRAPH_TEST_NAME = "zeroWeightsGraphTest1";

    public static String NEGATIVE_WEIGHTS_GRAPH_TEST_NAME = "negativeWeightsGraphTest1";

    public static String SELF_LOOPS_GRAPH_TEST_NAME = "selfLoopsGraphTest1";


    // Text used to annotate lines that should not be modified
    public static String DONT_MODIFY_COMMENT_STRING = "Don't modify";

    // Text used to annotate unit test comments indicating unit test is generated/completed by ChatGPT
    public static String AUTO_GENERATED_COMMENT_STRING = "Auto-Generated by ChatGPT";


    /**
     * Generates and writes a test class file for a specified OCD algorithm. This method dynamically constructs a test
     * class based on the characteristics and compatible graph types of the given OCD algorithm. The generated test
     * class implements appropriate test interfaces depending on the graph types compatible with the OCD algorithm.
     * For instance, OCD algorithms compatible with directed graphs will implement the DirectedGraphTestReq interface.
     * The created unit tests within the test class are partially complete and are designed to be finalized using a GPT.
     *
     * @param ocdaCode The file containing the OCD algorithm code. This file is parsed to determine the algorithm's
     *                  characteristics and compatible graph types.
     *
     * @implNote The method performs several key functions:
     * 1. Extracts the OCD algorithm name from the class file.
     * 2. Identifies compatible graph types for the algorithm.
     * 3. Determines the interfaces to be implemented by the test class based on the algorithm's compatibilities.
     * 4. Constructs the test class by appending necessary import statements, interface implementations, and partially completed unit tests.
     * 5. Writes the constructed test class to a Java file.
     *
     * The generated test class includes standard setup for unit tests, such as a setup method annotated with @BeforeEach.
     * The generated code section is marked with "ChatGPT Code" to indicate where the GPT should complete the unit tests.
     */
    public static void generateAndWriteOCDTestClass(File ocdaCode){

        // Extract OCD algorithm name from the class file
        String ocdaName = OCDAParser.getClassName(ocdaCode);

        // Extract compatible graph types for the given algorithm
        List<String> compatibilities = OCDAParser.extractCompatibilities(ocdaCode);

        // String that will hold interface names that an OCDA test class should implement
        String baseInterfaceNamesToImplement = "";

        // All OCDA test classes implement test interface for algorithm parameters and undirected graph type
        baseInterfaceNamesToImplement += OCDAParameterTestReq.class.getSimpleName()
                + ", " + UndirectedGraphTestReq.class.getSimpleName();


        // Initialize an empty StringBuilder to concatenate strings
        StringBuilder stringBuilder = new StringBuilder();


        // Iterate through the list of compatible graph type strings and add corresponding interfaces
        // to the interfaces that the test class implements
        for (String graphType : compatibilities) {
            if (graphType.equals("GraphType.DIRECTED")){
                // test interface for directed graphs should be implemented in the OCDA test class
                baseInterfaceNamesToImplement+= ", " + DirectedGraphTestReq.class.getSimpleName();
            }
            if (graphType.equals("GraphType.WEIGHTED")){
                // test interface for directed graphs should be implemented in the OCDA test class
                baseInterfaceNamesToImplement+= ", " + WeightedGraphTestReq.class.getSimpleName();

            }
            if (graphType.equals("GraphType.ZERO_WEIGHTS")){
                // test interface for zero weight graphs should be implemented in the OCDA test class
                baseInterfaceNamesToImplement+= ", " + ZeroWeightsGraphTestReq.class.getSimpleName();

            }
            if (graphType.equals("GraphType.NEGATIVE_WEIGHTS")){
                // test interface for negative weights graphs should be implemented in the OCDA test class
                baseInterfaceNamesToImplement+= ", " + NegativeWeightsGraphTestReq.class.getSimpleName();

            }
            if (graphType.equals("GraphType.SELF_LOOPS")){
                // test interface for self loops graphs should be implemented in the OCDA test class
                baseInterfaceNamesToImplement+= ", " + SelfLoopsGraphTestReq.class.getSimpleName();

            }

        }

        // Merge import statements from the OCD algorithm class and its test class, since the algorithm class
        // imports might be needed for the test class if the user wants to test OCD algorithm methods.
        List<String> mergedImports = mergeAndSortLists(extractSortedImports(ocdaCode),
                generateTestClassImports(ocdaCode));



        /* Generate partially completed test class */


        // Append package to the test class
        stringBuilder.append("package " + TEST_CLASS_PACKAGE_STRING + ";").append("\n\n");

        // Append import statements to the test class
        mergedImports.forEach(importStatement -> stringBuilder.append(importStatement).append("\n"));

        // Add interface implementation and partially completed unit tests to the test class,
        // based on compatible graph types.
        stringBuilder.append("\n\n" +
                "public class " +  ocdaName +"Test implements "
                + baseInterfaceNamesToImplement + " {\n" +
                "\n" +
                "\tOcdAlgorithm algo;\n" +
                "\n" +
                "\t@BeforeEach\n" +
                "\tpublic void setup() {\n" +
                "\t\talgo = new "+ ocdaName +"();\n" +
                "\t}\n" +
                "\n" +
                "\t@Override\n" +
                "\tpublic OcdAlgorithm getAlgorithm() {\n" +
                "\t\treturn algo;\n" +
                "\t}\n" +
                "\n" +
                "\n" +
                "\t// ChatGPT Code \n" +
                "\n" +
                generatePartiallyCompletedGraphTypeTests(ocdaCode)+ "\n" +
                "}\n"
        );

        // Write test class to a file
        generateAndWriteFile("classfiles/"+ocdaName+"Test.java", stringBuilder.toString());


    }

    public static void main(String[] args) {
        File ocdaCode = new File(getOCDAPath("SskAlgorithm.java"));
        File ocdaTestCode = new File(getOCDATestPath("SskAlgorithmTest.java"));

        // Generate OCD algorithm test class with partially completed unit tests
        generateAndWriteOCDTestClass(ocdaCode);

        // Generate prompt that asks GPT to complete partially completed unit tests (the prompt includes unit tests)
        generateAndWriteGraphTypeRelatedTestPrompt(ocdaCode);

        // Generate prompt that asks GPT to generate a test for a specific OCD method. As a response to this, GPT will
        // ask for a method that should be tested. When this prompt is used, OCDA file should also be given as input.
        generateAndWriteOCDAMethodTestPrompt(ocdaCode);


    }

    /**
     * Generates a list of import statements for the test class of the OCD algorithm.
     * The import statements are tailored based on the provided OCD algorithm name and its compatibilities.
     *
     * @param ocdaCode The OCD algorithm class code for which the test class is being prepared.
     * @return A List of strings, each representing an import statement for the test class.
     */
    private static List<String> generateTestClassImports(File ocdaCode){

        String ocdaName = OCDAParser.getClassName(ocdaCode);
        List<String> compatibilities = OCDAParser.extractCompatibilities(ocdaCode);

        String multiLineString =
                "import static org.junit.jupiter.api.Assertions.*;\n" +
                "import org.junit.jupiter.api.BeforeEach;\n" +
                "import org.junit.jupiter.api.Test;\n" +
                "import java.util.HashMap;\n" +
                "import java.util.Map;\n" +
                "import org.la4j.matrix.dense.Basic2DMatrix;\n" +
                "import " + OCDATestExceptionHandler.class.getName() + ";\n" +
                "import " + OcdAlgorithm.class.getName() + ";\n" +
                "import " + OcdAlgorithm.class.getPackage().getName() + "." + ocdaName + ";\n" +
                "import " + Cover.class.getName() + ";\n" +
                "import " + CustomGraph.class.getName() + ";\n" +
                "import " + OcdTestGraphFactory.class.getName() + ";\n" +
                generateGraphTypeTestInterfaceImportString(compatibilities);

        String[] lines = multiLineString.split("\n");
        List<String> importStatementList = new ArrayList<>(Arrays.asList(lines));

        return importStatementList;
    }


    /**
     * Generates a prompt string containing partially completed unit tests based on graph types compatible with the
     * OCD algorithm. This prompt can be used with a GPT model to complete the partially completed tests.
     * The method also includes algorithm parameter definitions and the implementation of the
     * setParameters method from the algorithm code.
     *
     * @param ocdaCode A File object representing the OCD algorithm code.
     * @return A string representing the generated prompt, including partially completed unit tests,
     *         algorithm parameter definitions, and the implementation of the setParameters method.
     */
    public static void generateAndWriteGraphTypeRelatedTestPrompt(File ocdaCode) {

        // Initialize an empty StringBuilder to concatenate strings
        StringBuilder stringBuilder = new StringBuilder();

        // Add partially completed unit tests for each compatible graph type to the prompt string
        stringBuilder
                .append("### Partially completed unit tests")
                .append("\n\n")
                .append(generatePartiallyCompletedGraphTypeTests(ocdaCode))
                .append("\n");



        // Extract OCD algorithm parameter definitions from the algorithm code, together with their Javadoc comments.
        // Then append it to the prompt string
        stringBuilder
                .append("### Algorithm parameter definitions")
                .append("\n\n")
                .append("My algorithm has the following algorithm parameters and default paramter values:")
                .append("\n\n");
        for (String ocdParameter : OCDAParser.listNonFinalClassVariablesWithComments(ocdaCode)){
            stringBuilder
                    .append(ocdParameter)
                    .append("\n\n\n");
        }

        // Extract implementation of the setParameters method from the algorithm code and add it to the prompt string
        stringBuilder.append("### Implementation of the setParameters method")
                .append("\n\n")
                .append(getMethodImplementation(ocdaCode,SET_OCD_PARAMETERS_METHOD_NAME))
                .append("\n\n");



        // Write prompt for completing partially generated test classes
        generateAndWriteFile("prompts/"+OCDAParser.getClassName(ocdaCode)+"_unit_test_completion_prompt.txt", stringBuilder.toString());


    }


    /**
     * Generates a prompt for test generation for a specific OCD algorithm method.
     * The generated prompt includes import statements from the test class and the name of the algorithm, which is
     * extracted from the OCD algorithm class file. This OCD algorithm class file should be provided as input
     * together with the prompt text when the output of this method is used as an input prompt to GPT.
     *
     * As a response, the user will be prompted to provide a method name for which the test should be generated.
     *
     * @param ocdaCode     A File object representing the OCD algorithm code.
     * @return A string representing the generated prompt, including import statements and the algorithm's class name.
     */
    public static void generateAndWriteOCDAMethodTestPrompt(File ocdaCode){
        // Initialize an empty StringBuilder to concatenate strings
        StringBuilder stringBuilder = new StringBuilder();



        // Merge import statements from the OCD algorithm class and its test class, since the algorithm class
        // imports might be needed for the test class if the user wants to test OCD algorithm methods.
        List<String> importStatements = mergeAndSortLists(extractSortedImports(ocdaCode),
                generateTestClassImports(ocdaCode));


        // Add import statements from the test class to the prompt, such that GPT knows what is available for tests
        stringBuilder
                .append("Import statements in the test class are as follows:")
                .append("\n\"\n");

        importStatements.forEach(importStatement -> stringBuilder.append(importStatement).append("\n"));


        stringBuilder
                .append("\"")
                .append("\n\n");

        // Add name of the algorithm to the prompt
        stringBuilder
                .append("The full OCD algorithm code is provided as a file called ")
                .append(OCDAParser.getClassName(ocdaCode))
                .append(".java")
                .append("\n\n");


        // Write prompt for asking GPT to generate unit tests for specific OCD algorithm methods
        // As a response to this prompt GPT should ask the name of the method
        generateAndWriteFile("prompts/"+OCDAParser.getClassName(ocdaCode)
                +"_method_test_generation_prompt.txt", stringBuilder.toString());


    }




    /**
     * Generates import statements for test interfaces corresponding to compatible graph types.
     *
     * This method constructs import statements for each graph type compatible with a specific algorithm.
     * It first appends the import statement for the OCDAParameterTestReq class as this interface is implemented by
     * all OCDA test classes, independent of compatible graph types. Then, for each compatible graph type,
     * it converts the graph type to camel case and capitalizes the first letter (e.g., ZERO_WEIGHTS becomes
     * ZeroWeights). Then, it uses the graph type name to create import statement for the respective graph
     * test interface and add this import statement to a string of import statements that will be used in the prompt.
     * These interfaces for each graph type are assumed to be in the same package as the base
     * interface (BaseGraphTestReq) from which they inherit.
     *
     * @param compatibleGraphTypes A list of strings representing the compatible graph types (e.g. GraphType.DIRECTED).
     * @return A string containing import statements for each of the compatible graph type test interfaces.
     */
    private static String generateGraphTypeTestInterfaceImportString(List<String> compatibleGraphTypes){

        // Each OCDA in WebOCD should work on an undirected graph
        if (!compatibleGraphTypes.contains("GraphType.UNDIRECTED")){
            compatibleGraphTypes.add("GraphType.UNDIRECTED");
        }

        StringBuilder importString = new StringBuilder("import " + OCDAParameterTestReq.class.getName() + ";\n");

        // Package of the base test interface, the other test interfaces should be in the same package
        String baseTestInterfacePackage = BaseGraphTestReq.class.getPackage().getName();

        for (String compatibleGraphType : compatibleGraphTypes){

            // Turn graph type to a camel case, e.g. ZERO_WEIGHTS will be turned into zeroWeights
            String graphTypeCamelCase = toCamelCaseFromUnderscore(compatibleGraphType.split("\\.")[1]);

            // Capitalize the camel case string as it is common for class names
            String capitalizedGraphTypeCamelCase = capitalizeFirstLetter(graphTypeCamelCase);

            // Create an import statement based on a graph type that will be used in the prompt generator
            importString.append("import " + baseTestInterfacePackage + "."
                    + capitalizedGraphTypeCamelCase + "GraphTestReq;\n");
        }

        return importString.toString();
    }


    /**
     * Capitalizes the first letter of a given string.
     *
     * This method converts the first character of a string to uppercase while leaving the rest of the string unchanged.
     * If the string is null or empty, it returns the string as is. This method is useful for formatting strings
     * where the first letter needs to be capitalized, such as in class names or certain types of identifiers.
     *
     * @param str The string whose first letter is to be capitalized.
     * @return The string with its first letter capitalized, or the original string if it is null or empty.
     */
    public static String capitalizeFirstLetter(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }


    /**
     * Generates a unit test template for compatible graph types of the algorithm.
     * This method reads the specified OCD algorithm code file to determine compatible graph types,
     * then creates a unit test template for each type, excluding 'CONTENT_UNLINKED' and 'CONTENT_LINKED' types.
     * It also adds an artificial undirected type to the list of compatible graph types as each OCD algorithm in WebOCD
     * works on undirected graphs, even though this type does not exist as a separate GraphType.
     *
     * @param ocdaCode The OCDAParser code file from which to extract compatible graph types.
     * @return A string containing the generated unit test templates.
     */
    private static String generatePartiallyCompletedGraphTypeTests(File ocdaCode){

        StringBuilder unitTestTemplatesBuilder = new StringBuilder();


        // Map graph type strings to corresponding getter methods for fetching test graphs
        Map<String, String> graphTypeStringToTestNameMap = new HashMap<>();
        graphTypeStringToTestNameMap.put("GraphType.DIRECTED", PromptGenerator.DIRECTED_GRAPH_TEST_NAME);
        graphTypeStringToTestNameMap.put("GraphType.WEIGHTED", PromptGenerator.WEIGHTED_GRAPH_TEST_NAME);
        graphTypeStringToTestNameMap.put("GraphType.ZERO_WEIGHTS", PromptGenerator.ZERO_WEIGHTS_GRAPH_TEST_NAME);
        graphTypeStringToTestNameMap.put("GraphType.NEGATIVE_WEIGHTS", PromptGenerator.NEGATIVE_WEIGHTS_GRAPH_TEST_NAME);
        graphTypeStringToTestNameMap.put("GraphType.SELF_LOOPS", PromptGenerator.SELF_LOOPS_GRAPH_TEST_NAME);

        // Adding nonexistent Undirected graph type string to the map avoids code duplication when generating tests
        graphTypeStringToTestNameMap.put("GraphType.UNDIRECTED", PromptGenerator.UNDIRECTED_GRAPH_TEST_NAME);



        // parse compatible graph types for the algorithm (list entries are e.g. "GraphType.DIRECTED")
        List<String> compatibleGraphTypeStrings = OCDAParser.extractCompatibilities(ocdaCode);

        // Add artificial undirected type to create a test for an undirected graph without code duplication
        compatibleGraphTypeStrings.add("GraphType.UNDIRECTED");


        // generate test for each graph type except content unlinked and content linked, as those need rework in WebOCD. Content linked and content unlinked graphs are ignored for now as these need a complete rework in WebOCD.
        for (String compatibleGraphTypeString : compatibleGraphTypeStrings) {

            if (!compatibleGraphTypeString.equals("GraphType.CONTENT_UNLINKED")
                    && !compatibleGraphTypeString.equals("GraphType.CONTENT_LINKED")){

                // Build a unit test name based on the graph type that is tested
                StringBuilder testNameStringBuilder = new StringBuilder(graphTypeStringToTestNameMap.get(compatibleGraphTypeString));

                unitTestTemplatesBuilder.append(generateUnitTestString(testNameStringBuilder.toString(),
                        compatibleGraphTypeString));
                unitTestTemplatesBuilder.append("\n");
            }

        }


        return unitTestTemplatesBuilder.toString();
    }



    /**
     * Converts an underscore-separated string to camelCase format.
     * This method is particularly useful for transforming constant-style
     * (uppercase with underscores) variable names into camelCase variable names.
     * For example, an input string "ZERO_WEIGHTS" will be converted to "zeroWeights".
     *
     * @param s The underscore-separated string to be converted.
     * @return The camelCase version of the input string. If the input is empty
     *         or only contains underscores, an empty string is returned.
     */
    private static String toCamelCaseFromUnderscore(String s) {
        String[] parts = s.trim().split("_"); // Split on underscores
        if (parts.length == 0) return "";

        StringBuilder camelCaseString = new StringBuilder(parts[0].toLowerCase()); // First word stays as it is

        for (int i = 1; i < parts.length; i++) {
            camelCaseString.append(parts[i].substring(0, 1).toUpperCase()).append(parts[i].substring(1).toLowerCase());
        }

        return camelCaseString.toString();
    }


    /**
     * Generates a partially completed unit test string for a given test name and compatible graph type.
     * This method auto-generates the structure of a JUnit test method, including placeholders for
     * setting algorithm parameters and instantiating graph covers. It is designed to facilitate
     * the testing of the OCD algorithm on different types of graphs. The method includes pre-written
     * code sections that should not be modified, as well as placeholders where auto-generated code by
     * ChatGPT should be placed
     *
     * @param testName The name of the unit test method to be generated, reflecting the graph type.
     * @param compatibleGraphTypeString A string representing the graph type on which the OCD algorithm is to be tested.
     * @return A string representing a partially completed JUnit test method.
     */
    private static String generateUnitTestString(String testName, String compatibleGraphTypeString){
        StringBuilder unitTestStringBuilder = new StringBuilder();

        unitTestStringBuilder.append(
                "\t/**\n" +
                        "\t * " + AUTO_GENERATED_COMMENT_STRING + "\n" +
                        "\t */\n" +
                        "\t@Test\n" +
                        "\tpublic void " + testName + "() throws Exception {\n" +
                        "\t\ttry {\n" +
                        "\t\t\t" + generateGraphInstantiationString(compatibleGraphTypeString) + " // Don't modify\n" +
                        "\n" +
                        "\t\t\t//TODO: Set algorithm parameters here. To be completed by ChatGPT\n" +
                        "\n" +
                        "\t\t\t" + generateCoverInstantiationString(compatibleGraphTypeString) + " // Don't modify\n" +
                        "\t\t\t" +"assert cover.getCommunities().size() >= 1; // Don't modify\n" +
                        "\n" +
                        "\t\t} catch (Exception e){\n" +
                        "\t\t\t" +OCDATestExceptionHandler.class.getSimpleName()+".handleException(e); // Don't modify\n" +
                        "\t\t}\n" +
                        "\t}\n"
        );

        return unitTestStringBuilder.toString();
    }


    /**
     * Generates a string for instantiating a 'Cover' object, used in the execution of the OCDA algorithm on a graph.
     * This method creates a Java line of code that initializes a 'Cover' object by calling the OCDA algorithm's
     * 'detectOverlappingCommunities' method on a specific type of graph. The type of graph is determined based on the
     * provided compatible graph type string. This generated code line is intended to be used in the setup of unit tests
     * for the OCDA algorithm.
     *
     * @param compatibleGraphTypeString A string indicating the type of graph (e.g. GraphType.DIRECTED) used in the test.
     * @return A string representing a line of Java code for instantiating a 'Cover' object with the OCDA algorithm
     * and the specified graph.
     */
    private static String generateCoverInstantiationString(String compatibleGraphTypeString) {
        // Cover cover = getAlgorithm().detectOverlappingCommunities(weightedGraph); // Don't modify
        return "Cover cover = " + PromptGenerator.OCDA_GETTER +"().detectOverlappingCommunities(" + generateGraphVariableName(compatibleGraphTypeString) + ");";

    }

    /**
     * Generates a Java code string for instantiating a graph object based on a provided graph type string.
     * This method maps the input graph type string, which should follow the format of the GraphType enum
     * (e.g., "GraphType.DIRECTED"), to a corresponding method name for fetching test graphs. It then constructs
     * a line of code to instantiate a graph of the specified type using these method names. The method handles
     * various graph types, including directed, weighted, and others, and also handles an artificially added
     * undirected type for flexibility.
     *
     * @param compatibleGraphTypeString A string representing the graph type, matching the GraphType enum format.
     * @return A string representing a line of Java code for instantiating a graph object of the specified type.
     *         Returns an empty string if the graph type is not recognized or not mapped.
     */
    private static String generateGraphInstantiationString(String compatibleGraphTypeString){

        // map graph types to corresponding getter methods for fetching test graphs
        Map<String, String> graphTypeToMethodNameMap = new HashMap<>();
        graphTypeToMethodNameMap.put("GraphType.DIRECTED", PromptGenerator.DIRECTED_GRAPH_METHOD_NAME);
        graphTypeToMethodNameMap.put("GraphType.WEIGHTED", PromptGenerator.WEIGHTED_GRAPH_METHOD_NAME);
        graphTypeToMethodNameMap.put("GraphType.ZERO_WEIGHTS", PromptGenerator.ZERO_WEIGHTS_GRAPH_METHOD_NAME);
        graphTypeToMethodNameMap.put("GraphType.NEGATIVE_WEIGHTS", PromptGenerator.NEGATIVE_WEIGHTS_GRAPH_METHOD_NAME);
        graphTypeToMethodNameMap.put("GraphType.SELF_LOOPS", PromptGenerator.SELF_LOOPS_GRAPH_METHOD_NAME);

        // Add artificial undirected type to instantiate an undirected graph without code duplication
        graphTypeToMethodNameMap.put("GraphType.UNDIRECTED", PromptGenerator.UNDIRECTED_GRAPH_METHOD_NAME);



        String methodName = graphTypeToMethodNameMap.get(compatibleGraphTypeString);

        // create a string of graph variable declaration depending on the graph type
        if (methodName != null) {

            String InstantiationString = PromptGenerator.GRAPH_CLASS_NAME + " " + generateGraphVariableName(compatibleGraphTypeString)+ " = "
                    + PromptGenerator.GRAPH_FACTORY_CLASS_NAME + "." + methodName + "();";

            return InstantiationString;

        }
        return "";
    }


    /**
     * Creates a variable name for a graph instantiation to be used in unit tests based on the provided graph type string.
     * This method processes a graph type string (expected to be in a format like "GraphType.DIRECTED") and converts the
     * portion after the dot into camelCase, appending "Graph" at the end. For instance, "GraphType.DIRECTED" would be
     * converted to "directedGraph". This is particularly useful for generating descriptive and consistent variable names
     * in unit test code.
     *
     * @param compatibleGraphTypeString A string representing the graph type, in a format like "GraphType.SOMETYPE".
     * @return A string that represents the camelCase variable name for the graph, suitable for use in unit test code.
     */
    private static String generateGraphVariableName(String compatibleGraphTypeString){
        return toCamelCaseFromUnderscore(compatibleGraphTypeString.split("\\.")[1]) + "Graph";
    }



    /**
     * Generates a file at the specified relative path within the 'gpt' directory and writes the provided content to it.
     * If a file at the given path already exists, it will be overwritten. The method
     * creates a new file and uses a BufferedWriter to write the content. In case of any
     * IOExceptions, the exception is caught and its stack trace is printed.
     *
     * @param relativePath The relative path (within the 'gpt' directory) where the file will be created or overwritten.
     * @param content      The content to be written into the file.
     */
    private static void generateAndWriteFile(String relativePath, String content) {
        try {
            // Define the base directory
            File baseDirectory = new File("gpt");

            // Create the base directory if it does not exist
            if (!baseDirectory.exists()){
                baseDirectory.mkdir();
            }

            // Create a File object with the full path
            File file = new File(baseDirectory, relativePath);

            // Ensure the parent directories exist
            File parentDir = file.getParentFile();
            if (parentDir != null && !parentDir.exists()) {
                parentDir.mkdirs();
            }

            // Create a new file (or overwrite an existing one)
            if (!file.createNewFile() && !file.exists()) {
                throw new IOException("Failed to create file: " + file.getAbsolutePath());
            }

            // Write content to file
            try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) {
                writer.write(content);
                System.out.println("File '" + relativePath + "' has been generated and written in '" + baseDirectory.getAbsolutePath() + "'.");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
