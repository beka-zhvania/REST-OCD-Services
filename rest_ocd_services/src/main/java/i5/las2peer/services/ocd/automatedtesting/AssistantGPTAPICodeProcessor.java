package i5.las2peer.services.ocd.automatedtesting;

import i5.las2peer.services.ocd.algorithms.OcdAlgorithm;
import i5.las2peer.services.ocd.automatedtesting.helpers.FileHelpers;
import i5.las2peer.services.ocd.automatedtesting.helpers.FormattingHelpers;
import i5.las2peer.services.ocd.automatedtesting.helpers.OCDAMethodHelpers;
import i5.las2peer.services.ocd.automatedtesting.helpers.OCDWriter;
import i5.las2peer.services.ocd.automatedtesting.metric.*;

import java.io.File;
import java.util.*;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.JsonProcessingException;
import i5.las2peer.services.ocd.automatedtesting.ocdaexecutor.GradleTaskExecutor;
import i5.las2peer.services.ocd.automatedtesting.ocdparser.OCDAParser;

public class AssistantGPTAPICodeProcessor {

    /**
     * This variable holds path to the file that holds auto-generated unit tests. This file goes through
     * various processing steps and also is moved around. Keeping track of its location at all times simplifies
     * the processing steps.
     */
    public static String autoGeneratedTestClassPath = "";

    public static void main(String[] args) {
        String ocdaName = "SskAlgorithm";

        /* graph type related tests */
//        String gptPrompt = processGraphTypeRelatedGPTTestCodeAndGenerateSubsequentPrompt(ocdaName);

//        /* specific OCDA method tests */
        List<String> methodNames = Arrays.asList("method1", "calculateMemberships", "getMaxDifference");
        String gptPrompt = processOCDAMethodGPTTestCodeAndGenerateSubsequentPrompt(ocdaName, methodNames);


        System.out.println("gpt prompt is:");
        System.out.println("---------------");
        System.out.println(gptPrompt);


        //TODO: if there are no issues, merge the code into the main code

    }


    // process auto-generated test code generated by GPT that includes unit tests related to compatible graph
    // types of an OCD algorithm.
    /**
     * Processes auto-generated test code generated by GPT that includes unit tests related to compatible graph
     * types of an OCD (Overlapping Community Detection) algorithm. This method specifically
     * deals with test code that pertains to the graph types that are compatible with the given OCD algorithm.
     *
     * @param ocdaName The name of the OCD algorithm for which the test code is to be processed.
     * @return A String representing a prompt that holds any issues found with the auto-generated code.
     *         If no issues are found, the returned string is empty.
     */
    public static String processGraphTypeRelatedGPTTestCodeAndGenerateSubsequentPrompt(String ocdaName) {

        System.out.println("Generating graph type related partially completed unit tests and a reference test class file...");
        // Generate partially completed unit test class and a reference file used for evaluation of auto-generated tests
        GradleTaskExecutor.runInitializeGraphTypeTestRelatedFiles(ocdaName);
        System.out.println("Generation successful. Moving on to processing of GPT-generated tests...");
        // Process auto-generated tests from GPT and return issues found (if any)
        return processAutoGeneratedCode(ocdaName, true);
    }

    /**
     * Processes auto-generated test code generated by GPT that includes unit tests for specific methods of
     * an OCD (Overlapping Community Detection) algorithm. Unlike processGraphTypeRelatedGPTTestCode,
     * this method focuses on the unit tests related to the specific methods of the OCD algorithm itself.
     *
     * @param ocdaName The name of the OCD algorithm for which the method-specific test code is to be processed.
     * @return A String representing a prompt that holds any issues found with the auto-generated code.
     *         If no issues are found, the returned string is empty.
     */
    public static String processOCDAMethodGPTTestCodeAndGenerateSubsequentPrompt(String ocdaName, List<String> methodNames) {

        System.out.println("Generating OCDA method related partially completed unit tests for the following methods: '" + methodNames + "' and a reference test class file...");
        // Generate partially completed unit test class and a reference file used for evaluation of auto-generated tests
        GradleTaskExecutor.runInitializeOCDAMethodTestFiles(ocdaName, methodNames);

        // Process auto-generated tests from GPT and return issues found (if any)
        return processAutoGeneratedCode(ocdaName, false);
    }


    /**
     * Processes auto-generated test code generated by GPT related to either compatible graph types of the
     * OCD algorithm or general methods within the OCD algorithm.
     *
     * @param ocdaName The name of the OCD algorithm for which the method-specific test code is to be processed.
     * @param isForGraphTypeTest A Boolean flag indicating whether the test code is for graph type tests
     *                            (true) or for specific OCDA method tests (false).
     * @return A String representing a prompt that holds any issues found with the auto-generated code.
     *         If no issues are found, the returned string is empty.
     */
    public static String processAutoGeneratedCode(String ocdaName, Boolean isForGraphTypeTest){
        ArrayList<String> issues = evaluateGPTGeneratedCode(ocdaName, isForGraphTypeTest);
        //System.out.println("##### printing issues " + issues);
        StringBuilder stringBuilder = new StringBuilder();


        // If there are issues identified, generate a prompt for GPT to fix the issues
        if (issues.size() > 0) {
            String issuesPrompt = generateSubmetricIssueFixingPrompt();
            stringBuilder.append("I will give you a java test class code and issues that need to be fixed. Please fix all mentioned issues in the code and return the fixed code");
            stringBuilder.append("\n\n");
            stringBuilder.append("### Java code that has issues");
            stringBuilder.append("\n\n");
            stringBuilder.append(FileHelpers.readFileAsString(autoGeneratedTestClassPath));
            stringBuilder.append("\n\n\n");
            stringBuilder.append("### Issues to be fixed");
            stringBuilder.append("\n\n");
            stringBuilder.append(issuesPrompt);

        }

        // Return a string containing issues with the code, or an empty string if there are no issues found
        return stringBuilder.toString();
    }


    /**
     * Evaluates GPT-generated test code to determine if it meets the criteria outlined in various submetrics.
     * This evaluation process includes parsing the code, running the tests, and checking for modifications
     * against the expected standards. The method is designed to work with test code for either compatible
     * graph type tests or specific OCDA (Overlapping Community Detection Algorithm) method tests.
     *
     * @param ocdaName The name of the OCDA for which the test code is generated. This name is used to
     *                 locate and handle the specific test files.
     * @param isForGraphTypeTests A Boolean flag indicating whether the test code is for graph type tests
     *                            (true) or for specific OCDA method tests (false).
     * @return An ArrayList of Strings containing the list of issues found during the evaluation. If the
     *         code meets all the criteria, an empty list is returned, indicating that the auto-generated
     *         code can be merged with the main test class code.
     *
     * The method performs several steps in its evaluation:
     * 1. Resets submetrics before starting a new evaluation.
     * 2. Extracts and prepares unit tests from the auto-generated code.
     * 3. Checks if the code is parsable and runnable.
     * 4. Evaluates the code against OCD and Code Modification submetrics.
     * 5. Generates and writes a quality report based on the evaluation.
     * 6. Determines if the test code needs to be moved or merged based on the evaluation results.
     *
     * Issues such as parsing errors, runtime errors, and submetric failures are identified and returned as
     * a list for further improvement.
     */
    public static ArrayList<String> evaluateGPTGeneratedCode(String ocdaName, Boolean isForGraphTypeTests){

        // Reset sub-metrics before new evaluation
        resetAllSubMetrics();


        // Class name of the test class holding auto-generated tests
        String autoGeneratedOCDATestClassName = "Generated" + ocdaName + "Test";

        /*  Extract unit test list from a unitTestFilePath  */

        // Unit tests generated by GPT before they were parsed to check for parsing errors
        autoGeneratedTestClassPath = FileHelpers.getAutoGeneratedUnprocessedUnitTestPath(ocdaName + "_gpt_generated_tests.txt");

        // Extract unit tests and write them to a temporary class file to parse it. We need the temporary class file
        // to ensure that java parser parses it as a class, since parsing unit alone
        // (without being enclosed in a class) causes issues.
        TestClassMerger.extractAndWriteUnitTests(autoGeneratedTestClassPath, autoGeneratedTestClassPath); // overwrite the file content

        if (isForGraphTypeTests) {
            System.out.println("Checking auto-generated graph type related test code...");
        } else {
            System.out.println("Checking auto-generated specific OCDA method test code...");
        }

        /* Check if auto-generated code can be parsed */

        File unparsedGptOutput = new File(autoGeneratedTestClassPath);
        CodeValiditySubmetric.evaluateIsCodeParsable(unparsedGptOutput);

        if (!CodeValiditySubmetric.isNoParsingErrorFound()) {
            System.out.println("Parsing error(s) found! returning issues list.");

            // Generate code quality metric
            OCDATestCodeQualityMetric.generateAndWriteQualityReport(ocdaName,true, autoGeneratedTestClassPath);

            return CodeValiditySubmetric.getPromptImprovementRemarks();
        }

        /* Check if auto-generated code can be executed */

        // Merge successfully parsed unit tests into test class that holds auto-generated tests
        // located at autoGeneratedTestClassPath
        System.out.println("No parsing errors found. Merging new unit tests into auto-generated test class...");
        String autoGeneratedTestClassTemplate = FileHelpers.getAutoGeneratedUnparsedTestPath("Generated" + ocdaName + "Test.java");
        TestClassMerger.extractAndMergeUnitTests(autoGeneratedTestClassTemplate, autoGeneratedTestClassPath);
        autoGeneratedTestClassPath = autoGeneratedTestClassTemplate; // by this point, new auto-generated unit tests are merged into the template


        // Move file holding successfully parsed unit tests to a test source set so that tests can be executed
        String initial_location = OCDATestAutomationConstants.GPT_GENERATED_TEST_CLASS_CODE_LOCATION + autoGeneratedOCDATestClassName + ".java";
        String test_source_location = OCDATestAutomationConstants.PARSED_GPT_GENERATED_CODE_LOCATION + autoGeneratedOCDATestClassName + ".java";
        System.out.println("Moving auto-generated test class to test source root to be executed...");
        System.out.println("\t moving from: " + initial_location);
        System.out.println("\t moving to:   " + test_source_location);
        FileHelpers.moveFile(initial_location, test_source_location, true);
        autoGeneratedTestClassPath = test_source_location; // update auto-generated test class path to new location in the test source set


        System.out.println("Executing auto-generated test code...");
        /* Check if auto-generated code can be executed */
        CodeValiditySubmetric.evaluateIsCodeRunnable("Generated" + ocdaName + "Test");


        if (!CodeValiditySubmetric.isNoRuntimeErrorFound()) {
            System.out.println("Runtime errors found! Removing class from the test source set to be fixed.");
            System.out.println("\t moving from: " + test_source_location);
            System.out.println("\t moving to:   " + initial_location);
            FileHelpers.moveFile(test_source_location, initial_location, true);
            autoGeneratedTestClassPath = initial_location; // update auto-generated test class path to new location in the test source set
            System.out.println("Returning issues list.");

            // Generate code quality metric
            OCDATestCodeQualityMetric.generateAndWriteQualityReport(ocdaName,true, autoGeneratedTestClassPath);
            return CodeValiditySubmetric.getPromptImprovementRemarks();
        }

        System.out.println("No runtime errors found. Continuing with rest of the sub-metric evaluation...");


        /* Evaluate OCD and Code Modification sub-metrics */

        File autoGeneratedTests = new File(autoGeneratedTestClassPath);
        File ocdaCode = new File(FileHelpers.getOCDAPath("SskAlgorithm.java"));

        // class that holds similar tests as GPT input. This is used to check
        // if GPT modified something it was not supposed to
        File gptInputReference = new File(FileHelpers.getAutoGeneratedUnparsedTestPath("SskAlgorithmTest.java"));

        // Auto completed unit tests related to graph types have additional checks (e.g. OCDA parameter setting etc.)
        if (isForGraphTypeTests) {
            // Evaluate ratio of compatible graphs types that are tested in the test class of the algorithm as
            // described in the initial prompt given to ChatGPT
            OCDSubmetric.evaluateCompatibleGraphTypeTestRaio(autoGeneratedTests, ocdaCode);

            // Evaluate ratio of algorithm parameters that were adequately covered in the unit tests of the OCDA test
            // class as described in the initial prompt given to ChatGPT.
            OCDSubmetric.evaluateAlgorithmParameterUsageRatio(autoGeneratedTests, ocdaCode);
        }

        // Evaluate ratio of javadoc comments indicating auto-generated/completed code that were removed/altered
        CodeModificationSubmetric.evaluateMethodCommentModification(autoGeneratedTests, gptInputReference);

        // Evaluate the ratio of lines that were marked as not to be removed but were removed (among all  marked lines)
        CodeModificationSubmetric.evaluateLineModificationInTests(autoGeneratedTests, gptInputReference);

        // Generate code quality metric
        OCDATestCodeQualityMetric.generateAndWriteQualityReport(ocdaName,true, autoGeneratedTestClassPath);

        // If there are issues with the necesasry sub-metrics, move the code back to the initial location to be fixed in the subsequent prompts to GPT
        if((isForGraphTypeTests && OCDSubmetric.getOCDSumetricValue() < 0.99)
                || CodeModificationSubmetric.getCodeModificationSubmetricValue() < 0.99){
            System.out.println("Issues found with the necessary sub-metrics. Removing class from the test source set to be fixed...");
            System.out.println("\t moving from: " + test_source_location);
            System.out.println("\t moving to:   " + initial_location);
            FileHelpers.moveFile(test_source_location, initial_location, true);
            autoGeneratedTestClassPath = initial_location;

            // Merge necessary sub-metric issues together to return as a list
            ArrayList issuesMerged = new ArrayList();
            issuesMerged.addAll(OCDSubmetric.getPromptImprovementRemarks());
            issuesMerged.addAll(CodeModificationSubmetric.getPromptImprovementRemarks());


            return issuesMerged;
        }

        // if no issues found, return an empty list
        return new ArrayList<String>();
    }

    /**
     * Generates a prompt string that describes all the issues that cause the reduction in the sub-metric values
     * @return      A prompt that can be used with GPT to fix the issues related to auto-generated code.
     */
    public static String generateSubmetricIssueFixingPrompt () {
        StringBuilder stringBuilder = new StringBuilder();

        if (!(CodeValiditySubmetric.isNoParsingErrorFound() && CodeValiditySubmetric.isNoRuntimeErrorFound())){
            stringBuilder.append("The code is invalid. Please fix the following issues:");
            stringBuilder.append("\n");
            CodeValiditySubmetric.getPromptImprovementRemarks().forEach(issueString ->
                    stringBuilder
                            .append("\t")
                            .append(issueString)
                            .append("\n")
            );
            stringBuilder.append("\n");

        } else {
            if (OCDSubmetric.getPromptImprovementRemarks().size() > 0) {
                stringBuilder.append("The code has the following issues related to unit tests and OCD algorithm parameter setting. Please fix them:");
                stringBuilder.append("\n");
                OCDSubmetric.getPromptImprovementRemarks().forEach(issueString ->
                        stringBuilder
                                .append("\t")
                                .append(issueString)
                                .append("\n")
                );
            }
            if (CodeModificationSubmetric.getPromptImprovementRemarks().size() > 0 ) {
                stringBuilder.append("\n");
                stringBuilder.append("The code has the following issues related to modified lines or comments that were not supposed to be modified. Please fix them:");
                stringBuilder.append("\n");
                CodeModificationSubmetric.getPromptImprovementRemarks().forEach(issueString ->
                        stringBuilder
                                .append("\t")
                                .append(issueString)
                                .append("\n")
                );
            }
        }

//        if (!stringBuilder.toString().equals("")) {
//            stringBuilder.insert(0, "The provided code has some issues. Below is the description of the issues. Please fix all described issues and return the full code: \n\n");
//        }

        return stringBuilder.toString();
    }

    /**
     * Processes and writes auto-generated OCD algorithm parameters to a file in JSON format based on the given GPT
     * response. This method extracts the algorithm's parameters from the GPT response, validates them, and writes
     * the valid parameters to a file. It handles initializing the algorithm, extracting and validating parameters,
     * and writing them to a file for subsequent use in accuracy tests.
     *
     * @param gptResponse The response from GPT, expected to contain a JSON string with generated OCDA parameter values
     *                    among other data.
     */
    public static void processAndWriteAutoGeneratedOCDAParameters(String gptResponse){

        // Get the OCD algorithm code
        File ocdaCode = new File(FileHelpers.getOCDAPath("SskAlgorithm.java"));

        // Get fully qualified class name of the OCD algorithm and create an instance
        String ocdaClassName = OCDAParser.getFullyQualifiedClassName(ocdaCode);
        OcdAlgorithm algo = OCDAMethodHelpers.initializeOcdAlgorithm(ocdaClassName);
        String ocdaName = OCDAParser.getClassName(ocdaCode);

        // Convert parameters in the format that is used in setParameters method of OCDA
        Map<String, Object> parsedOCDAParameters = FormattingHelpers.extractJsonAndConvertToMap(gptResponse);
        Map<String, List<String>> stringifiedOCDAParameters = FormattingHelpers.convertValuesToStrings(parsedOCDAParameters);

        // Write OCDA parameters in JSON format to a file
        Map<String, Object> newMap = new HashMap<>();

        // Create a new map with an additional key that is the OCDA name (this makes dealing with multiple OCDA easier)
        newMap.put(ocdaName, stringifiedOCDAParameters);

        // Identify default parameter values to be used if the auto-generated value can't be used
        List<String> ocdaParameterDeclarationsList = OCDAParser.listNonFinalClassVariables(ocdaCode, false);
        Map<String, String> defaultParameterValues = OCDAParser.getDefaultParameterValues(ocdaParameterDeclarationsList);

        // Iterate over all the different parameter sets and check if the generated values are valid
        ArrayList<Map<String, String>> finalParameterValues = OCDAMethodHelpers.validateOCDAParameters(algo, stringifiedOCDAParameters, defaultParameterValues);

        // Create a JSON string from the final parameter values for given OCDA that should be used in tests
        String finalParametersJsonString = FormattingHelpers.convertListToJSONString(finalParameterValues);


        // Write valid OCDA parameters to a file to be used in tests
        OCDWriter.writeAlgorithmDataToFile("gpt/json/ocda_parameters.json", ocdaName, finalParametersJsonString);

    }

    /**
     * Creates a JSON string with two key-value pairs that hold prompt to be given to GPT
     * and the code to which the prompt refers (e.g. code that needs fixing).
     *
     * @param promptString The value for the 'prompt' key.
     * @param codeToFix    The value for the 'codeToFix' key.
     * @return A String representation of the JSON object.
     */
    public static String createJson(String promptString, String codeToFix) {
        Map<String, String> keyValuePairs = new HashMap<>();
        keyValuePairs.put("prompt", promptString);
        keyValuePairs.put("codeToFix", codeToFix);

        ObjectMapper objectMapper = new ObjectMapper();

        try {
            return objectMapper.writeValueAsString(keyValuePairs);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return "";
        }
    }


    /**
     * Resets all sub-metric values. This should be used before sub-metrics are re-evaluated
     */
    public static void resetAllSubMetrics(){
        CodeValiditySubmetric.resetSubmetricVariables();
        OCDSubmetric.resetOCDSubmetricVariables();
        CodeModificationSubmetric.resetSubmetricVariables();
        CoverageSubmetric.resetSubmetricVariables();
        CodeSmellSubmetric.resetSubmetricVariables();
    }


}
