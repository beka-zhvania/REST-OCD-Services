package i5.las2peer.services.ocd.automatedtesting.metric;

import i5.las2peer.services.ocd.automatedtesting.ocdparser.OCDAParser;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;

public class OCDATestCodeQualityMetric {

    public static void main(String[] args) {

        File gptOutputParsed = new File(OCDAParser.getOCDATestPath("SskAlgorithmTest1.java"));
        //File gptOutput = new File(OCDAParser.getOCDATestPath("SskAlgorithmTest.java"));
        File gptInput = new File("someFile.java");

        File ocdaCode = new File(OCDAParser.getOCDAPath("SskAlgorithm.java"));

        //--------------------



        //TODO: add parsing part
        //TODO: add code that moves autogenerated test class without parsing errors to algorithm package


        /* Hard requirements: submetrics for which it is highly desirable to have maximum value */

        LinkedHashMap<String, List<String>> promptImprovementInstructions = new LinkedHashMap<>();



        // Extract code smell information from PMD report
        CodeSmellSubmetric.evaluateCodeSmellSubmetric(OCDAParser.getClassName(ocdaCode) + "Test");


        /* Add prompt improvement remarks (if any) from each submetric to the list of instructions based on which
         * subsequent prompts to ChatGPT will be generated.
         */

        //promptImprovementInstructions.put(CodeValiditySubmetric.class.getSimpleName(), CodeValiditySubmetric.getPromptImprovementRemarks());
        promptImprovementInstructions.put(OCDSubmetric.class.getSimpleName(), OCDSubmetric.getPromptImprovementRemarks());
        promptImprovementInstructions.put(CodeModificationSubmetric.class.getSimpleName(), CodeModificationSubmetric.getPromptImprovementRemarks());
        promptImprovementInstructions.put(CodeSmellSubmetric.class.getSimpleName(), CodeSmellSubmetric.getPromptImprovementRemarks());



        System.out.println("PROMPT IMPROVEMENT INSTRUCTIONS:\n\n");
        for (String submetricName : promptImprovementInstructions.keySet()) {
            System.out.println(submetricName + " prompt instructions:");
            for (String promptInstruction : promptImprovementInstructions.get(submetricName)){
                System.out.println("\t"+promptInstruction);
            }
            System.out.println();
        }


    }


    // Evaluates all algorithm
    public static void EvaluateAllSubmetrics(File gptOutputParsed, File gptInput, File ocdaCode){
        // Evaluate if the autogenerated code that was successfully parsed is executable
        //CodeValiditySubmetric.evaluateIsCodeRunnable(gptOutputParsed);

        // Evaluate ratio of compatible graphs types that are tested in the test class of the algorithm as
        // described in the initial prompt given to ChatGPT
        OCDSubmetric.evaluateCompatibleGraphTypeTestRaio(gptOutputParsed, ocdaCode);

        // Evaluate ratio of algorithm parameters that were adequately covered in the unit tests of the OCDA test
        // class as described in the initial prompt given to ChatGPT.
        OCDSubmetric.evaluateAlgorithmParameterUsageRatio(gptOutputParsed, ocdaCode);

        // Evaluate ratio of javadoc comments indicating auto-generated/completed code that were removed/altered
        CodeModificationSubmetric.evaluateMethodCommentModification(gptOutputParsed, gptInput);

        // Evaluate the ratio of lines that were marked as not to be removed but were removed (among all  marked lines)
        CodeModificationSubmetric.evaluateLineModificationInTests(gptOutputParsed, gptInput);


        /* Soft requirements:submetrics for which it is maximum value is not necessary, but would be nice */


        // Extract code coverage values from the JaCoCo report. Note that this submetric does not
        // contribute to subsequent prompts. It is however used for code quality report generation
        CoverageSubmetric.evaluateCoverageSubmetric(OCDAParser.getClassName(ocdaCode));
    }

}
