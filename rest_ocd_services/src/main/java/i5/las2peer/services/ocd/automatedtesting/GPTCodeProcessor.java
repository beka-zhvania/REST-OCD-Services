package i5.las2peer.services.ocd.automatedtesting;

import i5.las2peer.services.ocd.algorithms.OcdAlgorithm;
import i5.las2peer.services.ocd.automatedtesting.helpers.*;
import i5.las2peer.services.ocd.automatedtesting.metric.*;

import java.io.File;
import java.util.*;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.JsonProcessingException;
import i5.las2peer.services.ocd.automatedtesting.ocdaexecutor.GradleTaskExecutor;
import i5.las2peer.services.ocd.automatedtesting.ocdparser.OCDAParser;

import static i5.las2peer.services.ocd.automatedtesting.helpers.OCDWriter.generateAndWriteFile;

public class GPTCodeProcessor {



    /**
     * This variable holds path to the file that holds auto-generated unit tests. This file goes through
     * various processing steps and also is moved around. Keeping track of its location at all times simplifies
     * the processing steps.
     */
    public static String autoGeneratedTestClassPath = "";

    public static void main(String[] args) {
        if (args.length > 0) {
            String ocdaName = args[1];
            String ocdaCodePath = FileHelpers.cleanDuplicateDirectories(FileHelpers.getOCDAPath(ocdaName + ".java"));
            switch (args[0]) {
                case "processGraphTypeRelatedGPTTestCodeAndGenerateSubsequentPrompt":
                    if (args.length > 1) {
                        String result = processGraphTypeRelatedGPTTestCodeAndGenerateSubsequentPrompt(ocdaName);
                        System.out.println(result);
                    } else {
                        System.out.println("OCDA name not provided for processing Graph Type Related GPT Test Code.");
                    }
                    break;
                case "processOCDAMethodGPTTestCodeAndGenerateSubsequentPrompt":
                    if (args.length > 2) { // Expecting at least one method name
                        List<String> methodNames = Arrays.asList(args).subList(2, args.length);
                        String result = processOCDAMethodGPTTestCodeAndGenerateSubsequentPrompt(ocdaName, methodNames);
                        // System.out.println(result);
                    } else {
                        System.out.println("OCDA name or method names not provided for GPT API Method Test Prompt.");
                    }
                    break;
                default:
                    System.out.println("Invalid argument: " + args[0]);
                    break;
            }
        } else {
            System.out.println("No arguments provided.");
        }
    }




    /**
     * Processes auto-generated test code generated by GPT that includes unit tests related to compatible graph
     * types of an OCD (Overlapping Community Detection) algorithm. This method specifically
     * deals with test code that pertains to the graph types that are compatible with the given OCD algorithm.
     *
     * @param ocdaName The name of the OCD algorithm for which the test code is to be processed.
     * @return A String representing a prompt that holds any issues found with the auto-generated code.
     *         If no issues are found, the returned string is empty.
     */
    public static String processGraphTypeRelatedGPTTestCodeAndGenerateSubsequentPrompt(String ocdaName) {


        // Class that holds GPT-generated tests. If GPT interaction includes multiple prompts, this file  will be
        // updated with modified tests (if any).
        File classWithOCDATests = new File(PathResolver.resolvePath("gpt/classfiles/"+ "Generated" + ocdaName +"Test.java"));

        // Generate class to hold auto-generated tests, unless such class already exists (e.g. from previous GPT
        // interactions that are not complete due to code issues needing to be fixed.
        if (!classWithOCDATests.exists()){
            System.out.println("Generating graph type related partially completed unit tests and a reference test class file...");
            // Generate partially completed unit test class and a reference file used for evaluation of auto-generated tests
            GradleTaskExecutor.runInitializeGraphTypeTestRelatedFiles(ocdaName);
            System.out.println("Generation successful. Moving on to processing of GPT-generated tests...");
        } else{
            System.out.println("Class file with some auto-generated tests " + classWithOCDATests.getName() +" already exists. Moving on to processing of GPT-generated tests...");
        }

        // Process auto-generated tests from GPT and return issues found (if any)
        return processAutoGeneratedCode(ocdaName, true, true);
    }

    /**
     * Processes auto-generated test code generated by GPT that includes unit tests for specific methods of
     * an OCD (Overlapping Community Detection) algorithm. Unlike processGraphTypeRelatedGPTTestCode,
     * this method focuses on the unit tests related to the specific methods of the OCD algorithm itself.
     *
     * @param ocdaName The name of the OCD algorithm for which the method-specific test code is to be processed.
     * @return A String representing a prompt that holds any issues found with the auto-generated code.
     *         If no issues are found, the returned string is empty.
     */
    public static String processOCDAMethodGPTTestCodeAndGenerateSubsequentPrompt(String ocdaName, List<String> methodNames) {

        System.out.println("Generating OCDA method related partially completed unit tests for the following methods: '" + methodNames + "' and a reference test class file...");

        // Class that holds GPT-generated tests. If GPT interaction includes multiple prompts, this file  will be
        // updated with modified tests (if any).
        File classWithOCDATests = new File(PathResolver.resolvePath("gpt/classfiles/"+ "Generated" + ocdaName +"Test.java"));

        // Generate partially completed unit test class and a reference file used for evaluation of auto-generated tests
        GradleTaskExecutor.runInitializeOCDAMethodTestFiles(ocdaName, methodNames);

        // Generate class to hold auto-generated tests, unless such class already exists e.g. from previous GPT
        // interactions that are not complete due to code issues needing to be fixed.
        if (!classWithOCDATests.exists()){
            System.out.println("Generating a reference test class file used for evaluation and partially completed test class with tests for the following specific OCDA methods: " + methodNames);
            // Generate partially completed unit test class and a reference file used for evaluation of auto-generated tests
            GradleTaskExecutor.runInitializeOCDAMethodTestFiles(ocdaName, methodNames);
            System.out.println("Generation successful. Moving on to processing of GPT-generated tests...");
        } else{
            System.out.println("Class file with some auto-generated tests " + classWithOCDATests.getName() +" already exists. Moving on to processing of GPT-generated tests...");
        }

        // Process auto-generated tests from GPT and return issues found (if any)
        return processAutoGeneratedCode(ocdaName, false, true);
    }


    /**
     * Processes auto-generated test code generated by GPT related to either compatible graph types of the
     * OCD algorithm or general methods within the OCD algorithm.
     *
     * @param ocdaName The name of the OCD algorithm for which the method-specific test code is to be processed.
     * @param isForGraphTypeTest A Boolean flag indicating whether the test code is for graph type tests
     *                            (true) or for specific OCDA method tests (false).
     * @param mergeIntoMainTestClass A Boolean flag indicating if the unit tests that pass validation should directly
     *                               be merged into the main test class of the algorithm. Setting this to false can be
     *                               useful if the user wants to review the tests before merging.
     * @return A String representing a prompt that holds any issues found with the auto-generated code.
     *         If no issues are found, the returned string is empty.
     */
    public static String processAutoGeneratedCode(String ocdaName, Boolean isForGraphTypeTest, Boolean mergeIntoMainTestClass){
        ArrayList<String> issues = evaluateGPTGeneratedCode(ocdaName, isForGraphTypeTest, mergeIntoMainTestClass);
        //System.out.println("##### printing issues " + issues);
        StringBuilder stringBuilder = new StringBuilder();

        //TODO move this functionality to PromptGenerator and the prompt should also be written

        // If there are issues identified, generate a prompt for GPT to fix the issues
        if (issues.size() > 0) {
            String issuesPrompt = generateSubmetricIssueFixingPrompt();
            stringBuilder.append("I will give you a java test class code and issues that need to be fixed. Please fix all mentioned issues in the code and return the fixed code. Make sure to return full code, even if it includes parts you already returned before");
            stringBuilder.append("\n\n");
            stringBuilder.append("### Java code that has issues");
            stringBuilder.append("\n\n");
            stringBuilder.append(FileHelpers.readFileAsString(autoGeneratedTestClassPath));
            stringBuilder.append("\n\n\n");
            stringBuilder.append("### Issues to be fixed");
            stringBuilder.append("\n\n");
            stringBuilder.append(issuesPrompt);

        }


        // Write prompt for generating OCDA parameters
        generateAndWriteFile(PathResolver.addProjectRootPathIfSet("gpt/prompts/") + ocdaName
                +"_ocda_issue_fixing_prompt.txt", stringBuilder.toString(), false);

        // Return a string containing issues with the code, or an empty string if there are no issues found
        return stringBuilder.toString();
    }


    /**
     * Evaluates GPT-generated test code to determine if it meets the criteria outlined in various submetrics.
     * This evaluation process includes parsing the code, running the tests, and checking for modifications
     * against the expected standards. The method is designed to work with test code for either compatible
     * graph type tests or specific OCDA (Overlapping Community Detection Algorithm) method tests.
     *
     * @param ocdaName The name of the OCDA for which the test code is generated. This name is used to
     *                 locate and handle the specific test files.
     * @param isForGraphTypeTests A Boolean flag indicating whether the test code is for graph type tests
     *                            (true) or for specific OCDA method tests (false).
     * @param mergeIntoMainTestClass A Boolean flag indicating if the unit tests that pass validation should directly
     *                               be merged into the main test class of the algorithm. Setting this to false can be
     *                               useful if the user wants to review the tests before merging.
     * @return An ArrayList of Strings containing the list of issues found during the evaluation. If the
     *         code meets all the criteria, an empty list is returned, indicating that the auto-generated
     *         code can be merged with the main test class code.
     *
     * The method performs several steps in its evaluation:
     * 1. Resets submetrics before starting a new evaluation.
     * 2. Extracts and prepares unit tests from the auto-generated code.
     * 3. Checks if the code is parsable and runnable.
     * 4. Evaluates the code against OCD and Code Modification submetrics.
     * 5. Generates and writes a quality report based on the evaluation.
     * 6. Determines if the test code needs to be moved or merged based on the evaluation results.
     *
     * Issues such as parsing errors, runtime errors, and submetric failures are identified and returned as
     * a list for further improvement.
     */
    public static ArrayList<String> evaluateGPTGeneratedCode(String ocdaName, Boolean isForGraphTypeTests, Boolean mergeIntoMainTestClass){

        // Reset sub-metrics before new evaluation
        resetAllSubMetrics();


        // Class name of the test class holding auto-generated tests
        String autoGeneratedOCDATestClassName = "Generated" + ocdaName + "Test";

        /*  Extract unit test list from a unitTestFilePath  */

        // Unit tests generated by GPT before they were parsed to check for parsing errors
        autoGeneratedTestClassPath = PathResolver.addProjectRootPathIfSet(FileHelpers.getAutoGeneratedUnprocessedUnitTestPath(ocdaName + OCDATestAutomationConstants.GPT_GENERATED_TEST_FILE_NAME_SUFFIX));

        // Extract unit tests and write them to a temporary class file to parse it. We need the temporary class file
        // to ensure that java parser parses it as a class, since parsing unit alone
        // (without being enclosed in a class) causes issues.
        TestClassMerger.extractAndWriteUnitTests(autoGeneratedTestClassPath, autoGeneratedTestClassPath); // overwrite the file content

        if (isForGraphTypeTests) {
            System.out.println("Checking auto-generated graph type related test code...");
        } else {
            System.out.println("Checking auto-generated specific OCDA method test code...");
        }

        /* Check if auto-generated code can be parsed */

        File unparsedGptOutput = new File(autoGeneratedTestClassPath);
        CodeValiditySubmetric.evaluateIsCodeParsable(unparsedGptOutput);

        if (!CodeValiditySubmetric.isNoParsingErrorFound()) {
            System.out.println("Parsing error(s) found! returning issues list.");

            // Generate code quality metric
           OCDATestCodeQualityMetric.generateAndWriteQualityReport(ocdaName,true, autoGeneratedTestClassPath);

            return CodeValiditySubmetric.getPromptImprovementRemarks();
        }

        /* Check if auto-generated code can be executed */

        // Merge successfully parsed unit tests into test class that holds auto-generated tests
        // located at autoGeneratedTestClassPath
        System.out.println("No parsing errors found. Merging new unit tests into auto-generated test class...");
        String autoGeneratedTestClassTemplate = PathResolver.addProjectRootPathIfSet(FileHelpers.getAutoGeneratedUnparsedTestPath("Generated" + ocdaName + "Test.java"));
        TestClassMerger.extractAndMergeUnitTests(autoGeneratedTestClassTemplate, autoGeneratedTestClassPath);
        autoGeneratedTestClassPath = autoGeneratedTestClassTemplate; // by this point, new auto-generated unit tests are merged into the template


        // Move file holding successfully parsed unit tests to a test source set so that tests can be executed

        // Use absolute path if project root is set in a gradle task to avoid path related issues
        String initial_location = PathResolver.resolvePath(OCDATestAutomationConstants.GPT_GENERATED_TEST_CLASS_CODE_LOCATION + autoGeneratedOCDATestClassName + ".java");
        String test_source_location = PathResolver.addProjectRootPathIfSet(OCDATestAutomationConstants.PARSED_GPT_GENERATED_CODE_LOCATION + autoGeneratedOCDATestClassName + ".java");
        System.out.println("Moving auto-generated test class to test source root to be executed...");
        System.out.println("\t moving from: " + initial_location);
        System.out.println("\t moving to:   " + test_source_location);
        FileHelpers.moveFile(initial_location, test_source_location, true);
        autoGeneratedTestClassPath = test_source_location; // update auto-generated test class path to new location in the test source set


        System.out.println("Executing auto-generated test code...");
        /* Check if auto-generated code can be executed */
        CodeValiditySubmetric.evaluateIsCodeRunnable("Generated" + ocdaName + "Test");


        if (!CodeValiditySubmetric.isNoRuntimeErrorFound()) {
            System.out.println("Runtime errors found! Removing class from the test source set to be fixed.");
            System.out.println("\t moving from: " + test_source_location);
            System.out.println("\t moving to:   " + initial_location);
            FileHelpers.moveFile(test_source_location, initial_location, true);
            autoGeneratedTestClassPath = initial_location; // update auto-generated test class path to new location in the test source set
            System.out.println("Returning issues list.");

            // Generate code quality metric
            OCDATestCodeQualityMetric.generateAndWriteQualityReport(ocdaName,true, autoGeneratedTestClassPath);
            return CodeValiditySubmetric.getPromptImprovementRemarks();
        }

        System.out.println("No runtime errors found. Continuing with rest of the sub-metric evaluation...");


        /* Evaluate OCD and Code Modification sub-metrics */

        File autoGeneratedTests = new File(autoGeneratedTestClassPath);
        File ocdaCode = new File(FileHelpers.getOCDAPath(ocdaName + ".java"));

        // class that holds similar tests as GPT input. This is used to check
        // if GPT modified something it was not supposed to
        File gptInputReference = new File(PathResolver.addProjectRootPathIfSet(FileHelpers.getAutoGeneratedUnparsedTestPath(ocdaName +"Test.java")));

        // Auto completed unit tests related to graph types have additional checks (e.g. OCDA parameter setting etc.)
        if (isForGraphTypeTests) {
            // Evaluate ratio of compatible graphs types that are tested in the test class of the algorithm as
            // described in the initial prompt given to ChatGPT
            OCDSubmetric.evaluateCompatibleGraphTypeTestRaio(autoGeneratedTests, ocdaCode);

            // Evaluate ratio of algorithm parameters that were adequately covered in the unit tests of the OCDA test
            // class as described in the initial prompt given to ChatGPT.
            OCDSubmetric.evaluateAlgorithmParameterUsageRatio(autoGeneratedTests, ocdaCode);
        }

        // Evaluate ratio of javadoc comments indicating auto-generated/completed code that were removed/altered
        CodeModificationSubmetric.evaluateMethodCommentModification(autoGeneratedTests, gptInputReference);

        // Evaluate the ratio of lines that were marked as not to be removed but were removed (among all  marked lines)
        CodeModificationSubmetric.evaluateLineModificationInTests(autoGeneratedTests, gptInputReference);



        // If there are issues with the necesasry sub-metrics, move the code back to the initial location to be fixed in the subsequent prompts to GPT
        if((isForGraphTypeTests && OCDSubmetric.getOCDSumetricValue() < 0.99)
                || CodeModificationSubmetric.getCodeModificationSubmetricValue() < 0.99){
            System.out.println("Issues found with the necessary sub-metrics. Removing class from the test source set to be fixed...");
            System.out.println("\t moving from: " + test_source_location);
            System.out.println("\t moving to:   " + initial_location);
            FileHelpers.moveFile(test_source_location, initial_location, true);
            autoGeneratedTestClassPath = initial_location;

            // Merge necessary sub-metric issues together to return as a list
            ArrayList issuesMerged = new ArrayList();
            issuesMerged.addAll(OCDSubmetric.getPromptImprovementRemarks());
            issuesMerged.addAll(CodeModificationSubmetric.getPromptImprovementRemarks());

            OCDATestCodeQualityMetric.generateAndWriteQualityReport(ocdaName, true, autoGeneratedTestClassPath);
            return issuesMerged;
        }

        // Evaluate code smell presence and return the list of tracked code smells if identified
        if (OCDATestCodeQualityMetric.includeCodeSmellSubmetric) {
            CodeSmellSubmetric.evaluateCodeSmellSubmetric("Generated" + ocdaName + "Test");


            if (CodeSmellSubmetric.getNoCodeSmellRatio() < 1) {
                System.out.println("Code smells found. Removing class from the test source set to be fixed...");
                System.out.println("\t moving from: " + test_source_location);
                System.out.println("\t moving to:   " + initial_location);
                FileHelpers.moveFile(test_source_location, initial_location, true);
                autoGeneratedTestClassPath = initial_location;

                OCDATestCodeQualityMetric.generateAndWriteQualityReport(ocdaName, true, autoGeneratedTestClassPath);
                // Return list of code smell related issue remarks
                return CodeSmellSubmetric.getPromptImprovementRemarks();
            }
        }

        if (OCDATestCodeQualityMetric.includeCoverageSubmetric) {
            CoverageSubmetric.evaluateCoverageSubmetric(ocdaName);

        }



        // If flag is set and no issues were found (this is the case when control flow comes to this point in code),
        // merge the unit tests into the main test class of the algorithm
        if (mergeIntoMainTestClass) {
            // Identify main test class for the specified OCD algorithm to which the unit test should be added
            File ocdaTestClass = new File(FileHelpers.getOCDATestPath(ocdaName + "Test.java"));

            try {
                System.out.println("Auto-generated code satisfies minimum quality criteria. Merging into " + ocdaTestClass);
                TestClassMerger.mergeTestClasses(ocdaTestClass, new File(autoGeneratedTestClassPath));
            } catch (Exception e) {
                System.out.println("Merging tests failed! " + e.getMessage());
            }
        }
        OCDATestCodeQualityMetric.generateAndWriteQualityReport(ocdaName, true, autoGeneratedTestClassPath);
        // if no issues found, return an empty list
        return new ArrayList<String>();
    }

    /**
     * Generates a prompt string that describes all the issues that cause the reduction in the sub-metric values
     * @return      A prompt that can be used with GPT to fix the issues related to auto-generated code.
     */
    public static String generateSubmetricIssueFixingPrompt () {
        StringBuilder stringBuilder = new StringBuilder();

        if (!(CodeValiditySubmetric.isNoParsingErrorFound() && CodeValiditySubmetric.isNoRuntimeErrorFound())){
            stringBuilder.append("The code is invalid. Please fix the following issues:");
            stringBuilder.append("\n");
            CodeValiditySubmetric.getPromptImprovementRemarks().forEach(issueString ->
                    stringBuilder
                            .append("\t")
                            .append(issueString)
                            .append("\n")
            );
            stringBuilder.append("\n");

        } else {
            if (OCDSubmetric.getPromptImprovementRemarks().size() > 0) {
                stringBuilder.append("The code has the following issues related to unit tests and OCD algorithm parameter setting. Please fix them:");
                stringBuilder.append("\n");
                OCDSubmetric.getPromptImprovementRemarks().forEach(issueString ->
                        stringBuilder
                                .append("\t")
                                .append(issueString)
                                .append("\n")
                );
            }
            if (CodeModificationSubmetric.getPromptImprovementRemarks().size() > 0 ) {
                stringBuilder.append("\n");
                stringBuilder.append("The code has the following issues related to modified lines or comments that were not supposed to be modified. Please fix them:");
                stringBuilder.append("\n");
                CodeModificationSubmetric.getPromptImprovementRemarks().forEach(issueString ->
                        stringBuilder
                                .append("\t")
                                .append(issueString)
                                .append("\n")
                );
            }
            if (OCDATestCodeQualityMetric.includeCodeSmellSubmetric && CodeSmellSubmetric.getPromptImprovementRemarks().size() > 0) {
                stringBuilder.append("\n");
                stringBuilder.append("The code has the following issues related to code smells. Please fix them:");
                stringBuilder.append("\n");
                CodeSmellSubmetric.getPromptImprovementRemarks().forEach(issueString ->
                        stringBuilder
                                .append("\t")
                                .append(issueString)
                                .append("\n")
                );
            }
        }

//        if (!stringBuilder.toString().equals("")) {
//            stringBuilder.insert(0, "The provided code has some issues. Below is the description of the issues. Please fix all described issues and return the full code: \n\n");
//        }

        return stringBuilder.toString();
    }

    /**
     * Processes and writes auto-generated OCD algorithm parameters to a file in JSON format based on GPT response.
     * This method extracts the algorithm's parameters from the GPT response (written to a file), validates them, and
     * writes the valid parameters to a file. It handles initializing the algorithm, extracting and validating
     * and writing them to a file for subsequent use in accuracy tests.
     *
     * @param ocdaName      Name of the OCD algorithm for which the OCDA accuracy test should be created base don the
     *                      auto-generated paramters.
     *
     */
    public static void extractOCDAParamsFromGPTResponseAndWriteToJSON(String ocdaName){

        // Get the OCD algorithm code
        String algorithmDirectoryPath = System.getProperty("user.dir") + File.separator + "/src/main/java/i5/las2peer/services/ocd/algorithms/";
        File ocdaCode = new File(algorithmDirectoryPath + ocdaName + ".java");


        // Get fully qualified class name of the OCD algorithm and create an instance
        String ocdaClassName = OCDAParser.getFullyQualifiedClassName(ocdaCode);
        OcdAlgorithm algo = OCDAMethodHelpers.initializeOcdAlgorithm(ocdaClassName);

        // Read GPT response that holds OCDA parameters
        String gptResponseFilePath = PathResolver.resolvePath(FileHelpers.getAutoGeneratedUnprocessedUnitTestPath(ocdaName + OCDATestAutomationConstants.GPT_GENERATED_OCDA_PARAMETERS_FILE_NAME_SUFFIX));
        String gptResponse = FileHelpers.readFileAsString(gptResponseFilePath);


        // Convert parameters in the format that is used in setParameters method of OCDA
        Map<String, Object> parsedOCDAParameters = FormattingHelpers.extractJsonAndConvertToMap(gptResponse);
        Map<String, List<String>> stringifiedOCDAParameters = FormattingHelpers.convertValuesToStrings(parsedOCDAParameters);

        // Write OCDA parameters in JSON format to a file
        Map<String, Object> newMap = new HashMap<>();

        // Create a new map with an additional key that is the OCDA name (this makes dealing with multiple OCDA easier)
        newMap.put(ocdaName, stringifiedOCDAParameters);

        // Extract full OCDA parameter declarations from the algorithm code, together with Javadoc comments (if present)
        List<String> ocdaParams = OCDSubmetric.extractParameterNamesFromDeclarations(ocdaCode);
        List<String> ocdaParameterDeclarationsList =  OCDAParser.listSelectedClassVariables(ocdaCode,false,ocdaParams);
        // Extract OCDA parameter names from the algorithm code

        // Identify default parameter values to be used if the auto-generated value can't be used
        Map<String, String> defaultParameterValues = OCDAParser.getDefaultParameterValues(ocdaParameterDeclarationsList);

        // Iterate over all the different parameter sets and check if the generated values are valid
        ArrayList<Map<String, String>> finalParameterValues = OCDAMethodHelpers.validateOCDAParameters(algo, stringifiedOCDAParameters, defaultParameterValues);

        // Create a JSON string from the final parameter values for given OCDA that should be used in tests
        String finalParametersJsonString = FormattingHelpers.convertListToJSONString(finalParameterValues);


        // Write valid OCDA parameters to a file to be used in tests
        String parameterFilePath = "gpt/json/ocda_parameters.json";
        System.out.println("Writing Auto-Generated Parameters to " + parameterFilePath);
        OCDWriter.writeAlgorithmParameterDataToFile(parameterFilePath, ocdaName, finalParametersJsonString);

    }


    /**
     * This method is used for processing response when using assistant GPT. GPT response, that includes
     * parameter values to be used in OCDA accuracy test are written to a file for further processing.
     * Then a Gradle task is called to generate OCDA accuracy test using the GPT-generated parameter
     * values that passed validation.
     * @param ocdaName  The name of the OCD algorithm for which the OCDA accuracy test is created.
     */
    public static void processGPTAssistantResponseForOCDAAccuracyTests(String gptResponse, String ocdaName){

        // Write GPT response to a file for further processing
        String gptResponseFilePath = FileHelpers.getAutoGeneratedUnprocessedUnitTestPath(ocdaName + OCDATestAutomationConstants.GPT_GENERATED_OCDA_PARAMETERS_FILE_NAME_SUFFIX);
        System.out.println("Writing GPT Response that holds OCDA Accuracy Parameters for Further Processing at Path: " + gptResponseFilePath);
        OCDWriter.generateAndWriteFile(gptResponseFilePath, gptResponse,false);

        // Create OCDA accuracy test based on auto-generated algorithm parameters and merge the test into the test class
        // of the algorithm.
        GradleTaskExecutor.runGenerateAndWriteOCDAAccuracyTest(ocdaName);
    }

    /**
     * Creates a JSON string with two key-value pairs that hold prompt to be given to GPT
     * and the code to which the prompt refers (e.g. code that needs fixing).
     *
     * @param promptString The value for the 'prompt' key.
     * @param codeToFix    The value for the 'codeToFix' key.
     * @return A String representation of the JSON object.
     */
    public static String createJson(String promptString, String codeToFix) {
        Map<String, String> keyValuePairs = new HashMap<>();
        keyValuePairs.put("prompt", promptString);
        keyValuePairs.put("codeToFix", codeToFix);

        ObjectMapper objectMapper = new ObjectMapper();

        try {
            return objectMapper.writeValueAsString(keyValuePairs);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return "";
        }
    }


    /**
     * Resets all sub-metric values. This should be used before sub-metrics are re-evaluated
     */
    public static void resetAllSubMetrics(){
        CodeValiditySubmetric.resetSubmetricVariables();
        OCDSubmetric.resetOCDSubmetricVariables();
        CodeModificationSubmetric.resetSubmetricVariables();
        CoverageSubmetric.resetSubmetricVariables();
        CodeSmellSubmetric.resetSubmetricVariables();
    }


}
