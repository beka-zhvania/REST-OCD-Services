package i5.las2peer.services.ocd.automatedtesting.metric;

import i5.las2peer.services.ocd.automatedtesting.helpers.FileHelpers;
import i5.las2peer.services.ocd.automatedtesting.ocdparser.OCDAParser;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static i5.las2peer.services.ocd.automatedtesting.OCDATestAutomationConstants.AUTO_GENERATED_COMMENT_STRING;
import static i5.las2peer.services.ocd.automatedtesting.OCDATestAutomationConstants.DONT_MODIFY_COMMENT_STRING;

public class CodeModificationSubmetric {

    /**
     * Ratio of lines within test methods that were not supposed to be modified and were not modified
     */
    private static double correctlyUnmodifiedMethodLineRatio = 1.0;

    /**
     * Ratio autogenerated/complete unit test comments that are correctly annotated as autogenerated
     */
    private static double autogeneratedTestAnnotationRatio = 1.0;

    /**
     * List that holds instructions that will be used to generate the prompt for improving ChatGPT code
     */
    private static ArrayList<String> promptImprovementRemarks = new ArrayList<>();


    /**
     * Weight of the ratio of lines within test methods that were not supposed
     * to be modified and were not modified. The weight is used to determine
     * how much does this value contribute to the submetric calculation.
     */
    private static double correctlyUnmodifiedMethodLineRatioWeight = 1.0;

    /**
     * Weight of the ratio autogenerated/complete unit test comments that
     * are correctly annotated as autogenerated The weight is used to determine
     * how much does this value contribute to the submetric calculation.
     */
    public static double autogeneratedTestAnnotationRatioWeight = 1.0;




    public static void main(String[] args) {
        File gptInput = new File(FileHelpers.getOCDATestPath("SskAlgorithmTest1.java"));
        File gptOutputParsed = new File(FileHelpers.getAutoGeneratedTestPath("GeneratedSskAlgorithmTest.java"));


        evaluateLineModificationInTests(gptOutputParsed,gptInput);
        evaluateMethodCommentModification(gptOutputParsed,gptInput);

        System.out.println("\n\nPrompt improvement remarks:");
        for (String remark : promptImprovementRemarks){
            System.out.println("\t"+remark);
        }

        System.out.println("\n\n" + "correctlyUnmodifiedMethodLineRatio = "+correctlyUnmodifiedMethodLineRatio + " | autogeneratedTestAnnotationRatio = "+autogeneratedTestAnnotationRatio);


    }


    /**
     * Compares Javadoc comments in unit tests between two Java files to check if comment port that indicated that
     * the method is autogenerated or completed by ChatGPT were modified or removed in the output file, even though
     * they were present in the input file given as a template in the prompt.
     *
     * @param gptOutput The output Java test class file to be compared.
     * @param gptInput  The input Java test class file used as a reference.
     * @return          The ratio of the autogenerated/complete unit test comments that are correctly
     *                  annotated as autogenerated
     */
    public static double evaluateMethodCommentModification(File gptOutput, File gptInput) {

        // Number of unit test comments annotated as auto-generated
        int annotatedCommentCount = 0;
        // Number of auto-generated/completed unit tests where comment indicating autogeneration was removed/altered
        int incorrectlyModifiedCommentsCount = 0;


        /* Method names for input and output test class files */
        List<String> inputTestClassFileMethods = OCDAParser.extractMethods(gptInput);
        List<String> outputTestClassFileMethods = OCDAParser.extractMethods(gptOutput);

        // Extract method names and their Javadoc comments from both files
        Map<String, String> inputComments = new HashMap<>();
        Map<String, String> outputComments = new HashMap<>();
        for (String methodName : inputTestClassFileMethods) {

            // Map each method to its corresponding comment in the input file
            inputComments.put(methodName, normalizeComment(OCDAParser.getMethodComment(gptInput,methodName)));

            // If the method from the input file is contained in the output file, then map method to its comment,
            // otherwise map method to an empty comment
            if (outputTestClassFileMethods.contains(methodName)){
                outputComments.put(methodName, normalizeComment(OCDAParser.getMethodComment(gptOutput,methodName)));
            } else {
                outputComments.put(methodName,"");
            }

        }

        // Iterate through each method in the input file
        for (Map.Entry<String, String> entry : inputComments.entrySet()) {
            String methodName = entry.getKey();
            String inputComment = entry.getValue();

            // Check if the method comment contains comment indication that the unit test is auto generated/completed
            if (inputComment.contains(AUTO_GENERATED_COMMENT_STRING) || inputComment.contains("Completed by ChatGPT")) {

                // If unit test has a comment marking it for auto-generation/completion increment corresponding counter
                annotatedCommentCount += 1;

                // Comment of the unit test from input file in the output file (if present)
                String outputComment = outputComments.getOrDefault(methodName, "");

                // Check if the part of the comment referring to autogeneration was modified in the output file
                if (!outputComment.contains(AUTO_GENERATED_COMMENT_STRING) && !outputComment.contains("Completed by ChatGPT")) {

                    // When a comment marking autocompleted tests is removed/altered increase corresponding counter
                    incorrectlyModifiedCommentsCount++;

                    // Add prompt instruction for code improvement that will be used for future prompts
                    String promptInstruction = "Javadoc comment of unit test '" + methodName + "' must include text '"
                            + AUTO_GENERATED_COMMENT_STRING + "'. However, this text was removed. " +
                            "Add it back.";
                    promptImprovementRemarks.add(promptInstruction);
                }
            }
        }

        // Calculate the ratio of autogenerated tests which are correctly annotated as such.
        if (annotatedCommentCount > 0) {
            autogeneratedTestAnnotationRatio = 1 - ((double) incorrectlyModifiedCommentsCount) / annotatedCommentCount;
        } else {
            autogeneratedTestAnnotationRatio = 1;
        }

        return autogeneratedTestAnnotationRatio;
    }

    /**
     * Normalizes a comment string by removing Java comment symbols and reducing all whitespace to a single space.
     * This method strips away comment delimiters and asterisks commonly used in Java doc comments and block comments.
     * It replaces any sequence of whitespace characters (including new lines) with a single space and trims leading
     * and trailing spaces from the comment. This normalization is useful for text comparison purposes where formatting
     * differences such as whitespace and comment syntax are irrelevant.
     *
     * @param comment The comment string to be normalized.
     * @return        A normalized version of the comment string, free from comment-specific syntax and with uniform spacing.
     */
    private static String normalizeComment(String comment) {
        return comment.replaceAll("/\\*\\*|\\*/|\\*", "") // Remove comment symbols
                .replaceAll("\\s+", " ")            // Replace all whitespace (including newlines) with a single space
                .trim();                            // Trim leading and trailing spaces
    }


    /**
     * Evaluates the ratio of lines that were incorrectly modified in the output file compared to the input file.
     * This method scans through methods in both input and output Java class files, focusing on lines annotated
     * with a specific comment (e.g., "Don't modify"). It calculates the ratio of lines that were not supposed
     * to be modified but were changed in the output file. The ratio is calculated as the number of incorrectly
     * modified lines divided by the total number of lines that were not supposed to be modified. A ratio of 1
     * (excluding weight) indicates that no line was modified incorrectly.
     *
     * @param gptOutput The output Java file to be evaluated.
     * @param gptInput  The input Java file used as the reference.
     * @return          The ratio of correctly unmodified code lines.
     */
    public static double evaluateLineModificationInTests(File gptOutput, File gptInput){
        // Method names for input and output test class files
        List<String> inputTestClassFileMethods = OCDAParser.extractMethods(gptInput);
        List<String> outputTestClassFileMethods = OCDAParser.extractMethods(gptOutput);

        // Total lines that was not supposed to be modified in the output file compared to the input file
        int totalLinesNotToModify = 0;
        // Total lines that were modified in the output file even though they were not supposed to be modified
        int incorrectlyModifiedLines = 0;

        // Check if method lines from input file that were not supposed to be modified were modified in the output file
        // when this is the case, add a corresponding instruction to the list of instructions for prompt improvement
        for (String methodName : inputTestClassFileMethods){

            if (outputTestClassFileMethods.contains(methodName)){

                // Get lines from a specified method in both input and output test class files annotated with a comment
                // indicating the line should not be modified
                List<String> inputClassMethodAnnotatedLines = OCDAParser.listAnnotatedLinesInMethod(gptInput,methodName,
                        DONT_MODIFY_COMMENT_STRING,false);
                List<String> outputClassMethodAnnotatedLines = OCDAParser.listAnnotatedLinesInMethod(gptOutput, methodName,
                        DONT_MODIFY_COMMENT_STRING,false);

                // Lines from input file with comment "Don't modify" increase line number that shouldn't be modified
                totalLinesNotToModify += inputClassMethodAnnotatedLines.size();

                // Normalize lines in input and output since differing number of spaces should be ignored
                List<String> normalizedInputFileMethodLines = inputClassMethodAnnotatedLines.stream()
                        .map(line -> line.replaceAll("\\s+", " ").trim())
                        .collect(Collectors.toList());

                List<String> normalizedOutputFileMethodLines = outputClassMethodAnnotatedLines.stream()
                        .map(line -> line.replaceAll("\\s+", " ").trim())
                        .collect(Collectors.toList());

                // Each line in the specified method of input test class file that was annotated with "don't modify"
                // should be present in the output test class file */
                for (String inputFileMethodLine : normalizedInputFileMethodLines) {
                    // If the line that was not supposed to be modified was modified, add remark for prompt improvement
                    if (!normalizedOutputFileMethodLines.contains(inputFileMethodLine)){

                        // When an incorrectly modified line is detected, increase the corresponding counter
                        incorrectlyModifiedLines += 1;

                        // Add prompt improvement instruction to be used in subsequent prompts to ChatGPT
                        String promptImprovementInstruction = "Code line '" + inputFileMethodLine + "' in method '"
                                + methodName + "' was modified, but it must be unmodified since it is annotated with '" + DONT_MODIFY_COMMENT_STRING +"' comment.";
                        promptImprovementRemarks.add(promptImprovementInstruction);
                    }
                }
            }

        }

        // Calculate the ratio of unmodified lines among all lines that were not supposed to be modified

        if (totalLinesNotToModify > 0) {
            correctlyUnmodifiedMethodLineRatio = 1 - ((double) incorrectlyModifiedLines) / totalLinesNotToModify;
        } else {
            correctlyUnmodifiedMethodLineRatio = 1;
        }

        return correctlyUnmodifiedMethodLineRatio;

    }


    /**
     * Calculates the total code modification sub-metric value based on the evaluation of each part.
     *
     * @return The calculated total code modification sub-metric value.
     */
    public static double getCodeModificationSubmetricValue(){
        return (correctlyUnmodifiedMethodLineRatio * correctlyUnmodifiedMethodLineRatioWeight
                + autogeneratedTestAnnotationRatio * autogeneratedTestAnnotationRatioWeight)
                / (correctlyUnmodifiedMethodLineRatioWeight + autogeneratedTestAnnotationRatioWeight);
    }

    /**
     * Resets variables of code modification submetric to be reused
     */
    public static void resetSubmetricVariables(){
        promptImprovementRemarks = new ArrayList<>();
        autogeneratedTestAnnotationRatio = 0;
        correctlyUnmodifiedMethodLineRatio = 0;

    }

    public static double getCorrectlyUnmodifiedMethodLineRatio() {
        return correctlyUnmodifiedMethodLineRatio;
    }

    public static double getAutogeneratedTestAnnotationRatio() {
        return autogeneratedTestAnnotationRatio;
    }

    public static double getCorrectlyUnmodifiedMethodLineRatioWeight() {
        return correctlyUnmodifiedMethodLineRatioWeight;
    }

    public static void setCorrectlyUnmodifiedMethodLineRatioWeight(double correctlyUnmodifiedMethodLineRatioWeight) {
        CodeModificationSubmetric.correctlyUnmodifiedMethodLineRatioWeight = correctlyUnmodifiedMethodLineRatioWeight;
    }

    public static double getAutogeneratedTestAnnotationRatioWeight() {
        return autogeneratedTestAnnotationRatioWeight;
    }

    public static void setAutogeneratedTestAnnotationRatioWeight(double autogeneratedTestAnnotationRatioWeight) {
        CodeModificationSubmetric.autogeneratedTestAnnotationRatioWeight = autogeneratedTestAnnotationRatioWeight;
    }

    public static ArrayList<String> getPromptImprovementRemarks() {
        return promptImprovementRemarks;
    }

}
